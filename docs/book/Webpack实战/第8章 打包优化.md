# 第8章 打包优化

[[toc]]

**软件工程领域的经验--不要过早优化，在项目初期不要看到任何优化点就拿来加到项目中，这样不但增加了复杂度，优化的效果也不会太理想。一般是当项目发展到一定规模后，性能问题随之而来，这时再去分析然后对症下药，才有可能达到理想的优化效果。**

## HappyPack
HappyPack是一个通过多线程来提升Webpack打包速度的工具。

### 工作原理
使用loader将各种资源进行转译处理是非常耗时的。包括使用babel-loader转译ES6+和ts-loader转译TypeScript。

1. 从配置中获取打包入口。
2. 匹配loader规则，并对入口模块进行转译。
3. 对转译后的模块进行依赖查找。
4. 对新找到的模块重复进行2和3，直到没有新的依赖模块。

webpack是单线程的，如果一个模块依赖几个其他模块，却必须串行执行。HappyPack可以开启多个线程，并行对不同模块进行转译。这样就可以本地计算资源提高打包速度。

### 单个loader的优化
要用HappyPack提供的loader来替换原有的loader，并将原有的那个通过HappyPack插件传进去。
```js
const HappyPack = require("happypack")；
module.exports = {
    module: {
        rule: [
            {
                test: /\.js$/,
                exclude: /node_modules/,
                loader: 'happpack/loader',
            }
        ]
    },
    plugins: [
        new HappyPack({
            loaders: [
                {
                    loader: 'babel-loader',
                    options: {
                        presets: ['react']
                    }
                }
            ]
        })
    ]
}
```

### 多个loader的优化

```js
const HappyPack = require("happypack")；
module.exports = {
    module: {
        rule: [
            {
                test: /\.js$/,
                exclude: /node_modules/,
                loader: 'happpack/loader?id=js',
            },
            {
                test: /\.ts$/,
                exclude: /node_modules/,
                loader: 'happypack/loader?id=ts'
            }
        ]
    },
    plugins: [
        new HappyPack({
            id: 'js',
            loaders: [
                {
                    loader: 'babel-loader',
                    options: {
                        presets: ['react']
                    }
                }
            ]
        }),
        new HappyPack({
            id: 'ts',
            loaders: [
                {
                    loader: 'ts-loader',
                    options: {}// ts options
                }
            ]
        })
    ]
}
```

## 缩小打包作用域
**提升性能的方法：增加资源或者缩小范围。增加资源就是指使用更多CPU和内存，用更多的计算能力来缩短执行任务的时间；缩小范围是针对任务本身，比如去掉冗余的流程，尽量不做重复性的工作。**

### exclude 和 indlude
exclude和include在配置loader时一般都会加上它们。对于JS来说，一般要把node_modules目录排除，exclude优先级更高。

### noParse
有些库希望webpack完全不要去解析的，库内部也不会有对其他模块的依赖，那么可以使用noParse对其进行忽略。
```js
module: {
    noParse: /lodash/
}
```
会忽略多有文件名中包含lodash的模块，这些模块仍然会被打包进资源文件，只不多webpack不会对其进行任何解析。

webpack3及之后还支持完整的路径匹配。
```js
module.exports = {
    module: {
        noParse: function(fullpath) {
            // fullpath是绝对路径，如：/Users/me/app/webpack-no-parse/lib/lodash.js
            return /lib/.test(fullpath);
        }
    }
}
```

### IgnorePlugin