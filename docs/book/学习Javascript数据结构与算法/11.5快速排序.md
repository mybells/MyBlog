## 11.5 快速排序

## 概念

快速排序：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据比另一部分的所有数据要小，再按这种方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，使整个数据变成有序序列。时间复杂度

实现步骤：

- 选择一个基准元素 target（一般选择第一个数）
- 将比 target 小的元素移动到数组左边，比 target 大的元素移动到数组右边
- 分别对 target 左侧和右侧的元素进行快速排序
  从上面的步骤中我们可以看出，快速排序也利用了分治的思想（将问题分解成一些小问题递归求解）

![快速排序](/images/学习Javascript数据结构与算法/quickSort.gif)

## 实现

#### 方法一：递归（占额外存储空间、理解容易）

```js
function quickSort(array) {
  if (array.length < 2) {
    return array;
  }
  const target = array[0];
  const left = [];
  const right = [];
  for (let i = 1; i < array.length; i++) {
    if (array[i] < target) {
      left.push(array[i]);
    } else {
      right.push(array[i]);
    }
  }
  return quickSort(left).concat([target], quickSort(right));
}
```

#### 方法二：标准递归（不需要额外存储空间，写法思路稍复杂）

1. 首先从 arr 中选择中间值作为主元。
2. 创建 i,j。i 指向 arr 第一个值，j 指向 arr 最后一个值。移动 i 直到找到一个比主元大的值，移动 j 直到找到一个比主元小的值，然后交换它们，重复这个过程，直到 i 超过了 j。这个过程将使得比主元小的值都排在主元之前，比主元大的值都排在主元之后。
3. 对划分后的数组两个数组（比主元小的值组成的子数组，比主元大的值组成的子数组）重复之前两个步骤，直至数组完全排序。

```js
function quickSort(arr, left, right) {
  if (arr.length < 2) return;
  left = left ? left : 0;
  right = right ? right : arr.length - 1;
  const pivot = arr[Math.floor((left + right) / 2)];
  let i = left;
  let j = right;
  while (i <= j) {
    while (arr[i] < pivot) {
      i++;
    }
    while (arr[j] > pivot) {
      j--;
    }
    if (i <= j) {
      [arr[i], arr[j]] = [arr[j], arr[i]];
      i++;
      j--;
    }
  }
  if (left < i - 1) {
    quickSort(arr, left, i - 1);
  }
  if (right > i) {
    quickSort(arr, i, right);
  }
  return arr;
}
```

#### 方法三：非递归方法

```js
function quickSort(arr, left, right) {
  left = left ? left : 0;
  right = right ? right : arr.length - 1;
  var stack = [];
  var pivot, i, j;
  stack.push(left);
  stack.push(right);

  while (stack.length) {
    j = right = stack.pop();
    i = left = stack.pop();
    pivot = arr[Math.floor((i + j) / 2)];
    while (i <= j) {
      while (arr[i] < pivot) {
        i++;
      }
      while (arr[j] > pivot) {
        j--;
      }
      if (i <= j) {
        [arr[i], arr[j]] = [arr[j], arr[i]];
        i++;
        j--;
      }
    }
    if (left < i - 1) {
      stack.push(left);
      stack.push(i - 1);
    }
    if (right > i) {
      stack.push(i);
      stack.push(right);
    }
  }
  return arr;
}
```
## 复杂度
时间复杂度：平均O(nlogn)，最坏O(n2)，实际上大多数情况下小于O(nlogn)

空间复杂度:O(logn)（递归调用消耗）

## 稳定性
不稳定